defmodule Reticulum.Reference.EncryptedVectorsTest do
  use ExUnit.Case, async: true

  alias Reticulum.Destination
  alias Reticulum.Identity
  alias Reticulum.Packet
  alias Reticulum.Packet.Context
  alias Reticulum.ReferenceRunner
  alias Reticulum.Transport.PacketCrypto

  test "decrypts group encrypted payload generated by reference token implementation" do
    group_key = bin_range(1..64)
    iv = bin_range(201..216)
    plaintext = <<1, 2, 3, 4, 5, 6>>

    ciphertext =
      ReferenceRunner.run!("token_encrypt_fixed_iv", [hex(group_key), hex(plaintext), hex(iv)])
      |> dehex()

    {:ok, destination} = Destination.new(:in, :group, "phase6", nil, ["vector-group"])
    {:ok, destination} = Destination.load_group_key(destination, group_key)

    packet = %Packet{destination: :group, type: :data, context: Context.none(), data: ciphertext}

    assert {:ok, decrypted} = PacketCrypto.decrypt_inbound(packet, %{destination: destination})
    assert decrypted.data == plaintext
  end

  test "decrypts ratcheted single payload generated by reference identity" do
    private_key = deterministic_private_key()
    fixture = reference_identity_fixture(private_key)
    ratchet_private = :crypto.strong_rand_bytes(32)
    {:ok, ratchet_public} = Destination.ratchet_public_key(ratchet_private)
    plaintext = <<8, 7, 6, 5, 4, 3>>

    ciphertext =
      ReferenceRunner.run!("identity_encrypt", [
        fixture["public_key"],
        hex(plaintext),
        "-",
        hex(ratchet_public)
      ])
      |> dehex()

    destination = build_single_destination(fixture, ratchet_private, true)
    packet = %Packet{destination: :single, type: :data, context: Context.none(), data: ciphertext}

    assert {:ok, decrypted} = PacketCrypto.decrypt_inbound(packet, %{destination: destination})
    assert decrypted.data == plaintext
  end

  test "ratchet enforcement rejects non-ratcheted payload generated by reference identity" do
    private_key = deterministic_private_key()
    fixture = reference_identity_fixture(private_key)
    ratchet_private = :crypto.strong_rand_bytes(32)
    plaintext = <<9, 9, 9, 9>>

    ciphertext =
      ReferenceRunner.run!("identity_encrypt", [
        fixture["public_key"],
        hex(plaintext),
        "-",
        "-"
      ])
      |> dehex()

    destination = build_single_destination(fixture, ratchet_private, true)
    packet = %Packet{destination: :single, type: :data, context: Context.none(), data: ciphertext}

    assert {:error, :ratchet_enforced} =
             PacketCrypto.decrypt_inbound(packet, %{destination: destination})
  end

  defp build_single_destination(fixture, ratchet_private, enforce_ratchets) do
    identity =
      %Identity{}
      |> Map.put(:enc_sec, dehex(fixture["enc_sec"]))
      |> Map.put(:enc_pub, dehex(fixture["enc_pub"]))
      |> Map.put(:sig_sec, dehex(fixture["sig_sec"]))
      |> Map.put(:sig_pub, dehex(fixture["sig_pub"]))
      |> Identity.update_hash()

    {:ok, destination} = Destination.new(:in, :single, "phase6", identity, ["vector-ratchet"])
    {:ok, destination} = Destination.set_ratchets(destination, [ratchet_private])
    {:ok, destination} = Destination.enforce_ratchets(destination, enforce_ratchets)
    destination
  end

  defp reference_identity_fixture(private_key) do
    private_key
    |> hex()
    |> then(&ReferenceRunner.run!("identity_fixture", [&1]))
    |> ReferenceRunner.parse_kv_lines()
  end

  defp deterministic_private_key, do: bin_range(1..64)
  defp hex(data), do: Base.encode16(data, case: :lower)
  defp dehex(data), do: Base.decode16!(data, case: :mixed)

  defp bin_range(range) do
    range
    |> Enum.to_list()
    |> :binary.list_to_bin()
  end
end
